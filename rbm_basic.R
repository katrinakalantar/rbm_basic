####
##### Basic Concept RBM for Pathogen Detection from mNGS Data
####

setwd("~/code/rbm_basic")
source("./idseqr/R/idseqr.R") # from https://github.com/czbiohub/idseqr

library(reshape2)
#library(pheatmap)
#library(RColorBrewer)
library(dplyr)

# function to get maximum drop-off from a single sample (used for identify the outlier organisms)
get_difs <- function(l){
  difs <- list()
  for(i in seq_along(l[1:length(l)-1])){
    difs[[i]] <- l[i] - l[i+1]
  }
  return(unlist(difs))
}

# function to apply the RBM from background-corrected data matrix
apply_rbm <- function(df, overview, id){
  values <- sort(df[,id][!is.na(df[,id])], decreasing = TRUE)
  if(length(values) > 15){
    values <-  values[1:15]                   # restrict analysis to the top 15 organisms   
  }
  x <- get_difs(values)                       # identify the index of the maximum drop-off in RPM values
  if(length(x) == 0){
    top_orgs <- values
  }else{
    top_orgs <- values[1:which.max(x)]
  }
  return(top_orgs)
}

##
## read in the microbe data and sample qc metrics
##

# read in microbe reports from CZ ID
microbe_reports <- read_microbe_reports('./data/czid_reports/', tax_level=1, min_nt_alignment_length=70, min_nr_alignment_length=0)

# read in the sample overview table containing necessary metadata
overview <- read.csv("./data/sample_overviews.csv")

samplenames <- unique(microbe_reports$sample_name)

# read in the pathogen_list associated with this particular study
pathogen_list <- scan("./reference/priority_pathogens.txt", what="", sep="\n")

# compute the total input mass based on ERCCs [extra information to provide with outputs]
# formula: total mass / ercc mass = total reads / ercc reads

total_input_mass <- (overview$total_reads / overview$total_ercc_reads) * 25
initial_input_mass <- total_input_mass - 25
overview$initial_input_mass_ng <- initial_input_mass/1000


##
## Perform background correction using the function generated by Jack Kamm (https://github.com/czbiohub/idseqr)!
##

# NOTE: you may need to adjust this based on how the waters were indicated in metadata sheet
water_controls <- as.character(overview[overview$sample_type %in% c("Water"),c("sample_name")])   

microbe_reports_bgc <- filter_background(microbe_reports, water_controls)
microbe_reports_bgc$p_adj <- p.adjust(microbe_reports_bgc$p_val, "fdr")  ## apply multiple test correction (fdr = Benjamini & Hochberg)
sig_microbe_reports_bgc <- microbe_reports_bgc[microbe_reports_bgc$p_adj < .01,]
microbe_reports <- sig_microbe_reports_bgc

# write out the per-sample, background-filtered microbe reports
for(i in unique(microbe_reports$sample_name)){
  print(i)
  this_microbe_report <- microbe_reports[microbe_reports$sample_name == i,]
  write.csv(this_microbe_report, paste(list("./output/",i,"_bgc.csv"), collapse=''))
}

# write out the full, joint-across-all-samples, background-filtered microbe reports
write.csv(microbe_reports, "./output/all-background-filtered-counts.csv")


# from the significat taxa, identify viral hits by the following criteria: 
# 1. category == virus
# 2. nt_rpm > 0.1

sig_microbe_reports_bgc %>% 
  filter(category == "viruses") %>% 
  filter(nt_rpm > .1) -> virus_hits
write.csv(virus_hits[,c("sample_name","tax_id","name","nt_rpm","nt_count")], "./output/virus_hits.csv", quote=FALSE)


##
## Apply the RBM to background-corrected data
##

result_info <- c()       # list of all results that will be output
result_info_2 <- list()  # alternative format listing all results 

# loop through all the samples and apply the RBM
for(sn in samplenames){
  
  print(sn)
  this_report <- microbe_reports[microbe_reports$sample_name == sn,]  # select this particular sample to operate on
  
  # get genus counts by summing across species 
  # this value is only used if using the PNAS method, otherwise just use nt_rpm below
  this_report %>% 
    group_by(genus_tax_id) %>% 
    summarise(nt_count = sum(nt_count)) %>%
    as.data.frame() -> genus_counts
  colnames(genus_counts) <- c("genus_tax_id", "genus_nt_count")
  
  merged_report <- merge(this_report, genus_counts, by="genus_tax_id")
  
  # could just pass this_report here if we don't use genus-level counts
  merged_report %>%
    dplyr::filter(genus_tax_id > 0) %>%  # require genus taxid (removes "uncultured bacteria")
    dplyr::filter(nr_count > 0) %>%      # filter out taxons with 0 NR reads
    group_by(genus_tax_id) %>%           # group by genus, select the top species within the genus
    top_n(1, abs(nt_rpm)) %>% 
    as.data.frame() -> filtered_report
  
  if(dim(filtered_report)[1] > 0){
    mat <- acast(filtered_report, name~sample_name, value.var="nt_rpm")
    # Below was the previous method (from PNAS paper) in which we used genus count and assigned species name
    #mat <- acast(filtered_report, name~sample_name, value.var="genus_nt_count")  
    result_info <- c(result_info, sn)
    
    # optional, include line for calculated input mass in output 
    #mass <- overview[overview$sample_name == sn,c("initial_input_mass_ng")]
    #result_info <- c(result_info, mass)
    
    result <- apply_rbm(mat, overview, 1)  
    print(result)
    
    # NOTE: the `result` variable now contains the RBM-called taxa based on abundance outliers...
    # ...   but does not filter for "known pathogens" based on a priority include-list. 
    # filter on exact species match OR fuzzy genus match
    keep_taxa <- unlist(lapply(names(result), function(x){if(x %in% pathogen_list || 
                                                             strsplit(x, " ")[[1]][1] %in% pathogen_list){return(x)}}))  
    print(keep_taxa)
    result <- result[keep_taxa]
    
    # format output results
    result_info_2[[sn]] <- list()  # another way to collect results
    for(i in names(result)){
      result_info <- c(result_info, paste(c(i, result[[i]]), collapse = ": "))
      result_info_2[[sn]][[i]] <- result[[i]]
    }
    result_info <- c(result_info, "--")
  }
  
}
sink("./output/rbm_results.txt")
# file contains sample name, followed by RBM-called microbes with NT rPM values
writeLines(unlist(lapply(result_info, paste, collapse=" "))) 
sink()


